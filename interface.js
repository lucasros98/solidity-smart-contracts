
Web3 = require('web3')
web3 = new Web3('HTTP://127.0.0.1:7545')
//Note that this code assumes you haven't changed the default port Ganache
//uses from 7545
eu = require('ethereumjs-util')


//Marshalling numbers to hex
function bytesToHex2(bs){
    var accum = ""
    bs.map(b => accum += byteToHex(b))
    return accum
}
function byteToHex(b){
    var hi = Math.floor(b/16)
    var lo = b%16
    return nibbleToHex(hi) + nibbleToHex(lo)
}
function nibbleToHex(n){
    return ("0123456789abcdef".split(''))[n]
}
function extend2(byteLen,n){
    var acc = Array(byteLen)
    var i = byteLen - 1
    while(i > -1){
	acc[i] = n % 256
	n = Math.floor(n/256)
	i--
    }
    return acc
}
//Converts a bigint n to a b-byte hexstring without a 0x prefix
function extend(b,n){
    return bytesToHex2(extend2(b,n))
}

//Crypto interface code
function pubKeyOf(k) {
    var word = '0x'
    for(var i = 0; i < 32; i++)word+='ee'
    return ecrecover(word,signWithSecretKey(k,word))
}

//The sign functions take a 256b hexstring and return a hexstring.
function signWithSecretKey(privkey,word) {
    var eusig = eu.ecsign(eu.toBuffer(word),
			  new Buffer(privkey,"hex"))
    return eu.bufferToHex(eusig.r) +
	eu.bufferToHex(eusig.s).substr(2) +
	extend(1,eusig.v)
}

//Two hexstrings -> address
function ecrecover(word,sig){
    return web3.eth.accounts.recover(word,sig,true)
}

//Signs an off-chain ledger state.
//secretKey: hexstring, OCL: {nonce: number > 0, balanceDelta: number}
//returns [sig,OCL].
//Both sig and OCL are of the right form to be recognized as Signature and
//OffChainLedger structs respectively when passed as arguments to methods in
//Truffle.
function signOCL(secretKey,OCL){
    if(OCL.nonce < 0) throw "The nonce is a uint (can't be negative)"
    //This creates a bytestring equal to the one generated by abi.encode in
    //Solidity.
    var message = web3.eth.abi.encodeParameters(["uint","int"],
						[OCL.nonce,
						 OCL.balanceDelta])
    var hash = web3.utils.sha3(message)
    var eusig = eu.ecsign(eu.toBuffer(hash),
			  new Buffer(secretKey,"hex"))
    return [{r: eu.bufferToHex(eusig.r),
	     s: eu.bufferToHex(eusig.s),
	     v: eusig.v},
	    OCL
	   ]
}

//A useful utility function, lets you reload JS modules loaded with require
function reload(filepath) {
    delete require.cache[require.resolve(filepath)]
    return require(filepath)
}

//Pass in the StateChannel class object to this
var StateChannel
function init(SC) {
    StateChannel = SC
}

//Creates a new payment channel between Alice and Bob and models the protocol.
//In reality this state would be distributed over two computers;
//Alice would not have access to Bob's secret key and vice versa.
//Note this is an asynchronous function; it returns a promise you must await
//to get the value of.
//Updating AliceBalance and BobBalance corresponds to Alice and Bob monitoring
//on-chain transactions and observing deposits and withdrawals from the payment
//channel. If you call methods of SC directly rather than going through the
//convo object returned by this the state of the object will become
//inconsistent.

/*
Convo (protocol) object specification:

nat = integer value of type number >= 0
int = integer value of type number

SC is the state channel object the protocol calls when depositing or withdrawing
funds.

balances : [nat,nat]
Should track the balances of both parties
in wei; it should be updated when users deposit and withdraw. It reflects
on-chain state and should NOT be changed when making an off-chain payment.

delta : int
The net number of wei owed by Alice to Bob as recorded by
the last signed ledger. This reflects off-chain state and should change when an
off-chain payment is made.

nonce : nat
Every off-chain ledger method contains a nonce so that newer ones (with higher
nonce) can dominate older ones and to prevent replay attacks on withdrawal. 
nonce is the value that should be used for the
next off-chain payment. Every time a payment is made, it's incremented.

secretKeys: [AliceSK,BobSK]
This should contain an array of two secret keys (which you copied to AliceSK
and BobSK earlier).

publicKeys: [Alice,Bob]
Contains the corresponding public keys.

messages: [[[sig,OCL],...],[[sig,OCL],...]]
Contains the messages sent by the respective parties. The signature,
off-chain ledger pairs can be generated using the helper function signOCL.
When one party sends a message that isn't rejected by the other for making a
negative payment, the signature and OCL 

withdrawalInProgress: boolean
Tracks whether there is currently a withdrawal in progress (if one has become
final due to its deadline passing but hasn't been completed yet, it should be
considered in progress).

*/
function newConvo(AliceSK,BobSK,value) {
    var Alice = pubKeyOf(AliceSK)
    var Bob = pubKeyOf(BobSK)
    return StateChannel.new(Bob,{from: Alice, value: value}).then(sc => {
	return {
	//State
	SC: sc,
	balances: [value,0],
	delta: 0,
	nonce: 1,
	secretKeys: [AliceSK,BobSK],
	publicKeys: [Alice,Bob],
	messages: [[],[]],
	withdrawalInProgress: false
	}
    })
}

//The index argument 0 or 1 corresponds to Alice or Bob.
//The function doesn't need to work for indices other than 0 or 1.
//You may assume the sender has enough funds and so the deposit completes
//successfully.
//value is a bigint
//c is a convo (payment channel protocol) object.
function deposit(ix,value,c) {
    var who = c.publicKeys[ix]
    return c.SC.deposit({from: who, value: value}).then(_ => {
	c.balances[ix] += value
    })
}

//Sends a payment from the party denoted by the 0 | 1 index ix.
//Fail with an error message if a withdrawal is in progress; you don't need to
//handle that.
//Fail if the user has insufficient funds.
//If the sender tries to make a non-positive payment, the recipient should
//ignore the signed message since it's of no use to them; model that by failing
//with an error message.
//Append the signed message sent to c.messages[ix] and update the delta (but
//not the balances).
//Note this shouldn't be an async function since it doesn't need to talk to
//the chain!
function pay(ix,value,c) {
    //Your code goes here
}
//Starts a zero-delta withdrawal from [Alice,Bob][ix]. This allows the parties
//to avoid exchanging zero-delta signed ledgers before they can safely deposit
//funds.
//Note attempting this when c.delta != 0 is not always malicious; consider a
//situation where Alice pays Bob 50 wei, but Bob is inactive and Alice wants the
//rest of her money back. Since she's not allowed to upload her own signed
//ledgers (that would create an attack), she must upload an outdated state.
async function withdrawWithoutSignature(ix,c) {
    var who = c.publicKeys[ix]
    await c.withdrawWithoutSignature({from: who})
}

//Starts a tentative withdrawal from [Alice,Bob][ix].
//Assume they're honest and aren't trying to steal money.
//This must be async because it interacts with the chain.
//Note uploading an outdated state is not necessarily malicous; if Alice is
//the last party to make a payment, she can't upload her own state and so must
//upload the last one she received from Bob.
//Fail with an error message if there's a withdrawal with a higher nonce in
//progress, or if a withdrawal is complete (awaiting completeWithdrawal).
async function startWithdrawal(ix,c) {
    //Your code goes here
}

//Local UNIX time in seconds. We assume the blockchain node's time doesn't
//diverge too much (and it won't in our case since we're running a private chain
//locally).
function time(){
    return Math.floor(Date.now() / 1000)
}

//Return an error string if there is no withdrawal to complete or if the
//deadline hasn't passed yet.
//You may assume that the completeWithdrawal method will not be preempted by
//another completeWithdrawal bypassing the convo object.
async function completeWithdrawal(ix,c) {
    //Your code goes here
}

module.exports = {
    pubKeyOf,
    signWithSecretKey,
    signOCL,
    reload,
    init,
    newConvo,
    deposit,
    pay,
    startWithdrawal,
    completeWithdrawal
}
